#!/usr/bin/env bash
set -e

version() {
  echo "Bats 0.4.0"
}

usage() {
  version
  echo "Usage: bats [-c] [-p | -t] <test> [<test> ...]"
}

help() {
  usage
  echo
  echo "  <test> is the path to a Bats test file, or the path to a directory"
  echo "  containing Bats test files."
  echo
  echo "  -c, --count    Count the number of test cases without running any tests"
  echo "  -h, --help     Display this help message"
  echo "  -p, --pretty   Show results in pretty format (default for terminals)"
  echo "  -t, --tap      Show results in TAP format"
  echo "  -v, --version  Display the version number"
  echo
  echo "  For more information, see https://github.com/bats-core/bats-core"
  echo
}

BATS_READLINK=

resolve_link() {
  if [[ -z "$BATS_READLINK" ]]; then
    if command -v 'greadlink' >/dev/null; then
      BATS_READLINK='greadlink'
    elif command -v 'readlink' >/dev/null; then
      BATS_READLINK='readlink'
    else
      BATS_READLINK='true'
    fi
  fi
  "$BATS_READLINK" "$1" || return 0
}

abs_dirname() {
  local cwd="$PWD"
  local path="$1"

  while [ -n "$path" ]; do
    cd "${path%/*}"
    local name="${path##*/}"
    path="$(resolve_link "$name")"
  done

  printf -v "$2" -- '%s' "$PWD"
  cd "$cwd"
}

expand_path() {
  local path="${1%/}"
  local dirname="${path%/*}"

  if [[ "$dirname" == "$path" ]]; then
    dirname="$PWD"
  elif cd "$dirname" 2>/dev/null; then
    dirname="$PWD"
    cd "$OLDPWD"
  else
    printf '%s' "$path"
    return
  fi
  printf -v "$2" '%s/%s' "$dirname" "${path##*/}"
}

abs_dirname "$0" 'BATS_LIBEXEC'
abs_dirname "$BATS_LIBEXEC" 'BATS_PREFIX'
abs_dirname '.' 'BATS_CWD'

export BATS_PREFIX
export BATS_CWD
export BATS_TEST_PATTERN="^[[:blank:]]*@test[[:blank:]]+(.*[^[:blank:]])[[:blank:]]+\{(.*)\$"
export PATH="$BATS_LIBEXEC:$PATH"
export BATS_COUNT_ONLY=false
export BATS_PRETTY_FORMAT=false

if [[ -t 0 && -t 1 ]]; then
  BATS_PRETTY_FORMAT=true
fi
if [[ -n "${CI:-}" ]]; then
  BATS_PRETTY_FORMAT=false
fi

declare -a arguments=()

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -h | --help )
      help
      exit 0
      ;;
    -v | --version )
      version
      exit 0
      ;;
    -c | --count )
      BATS_COUNT_ONLY=true
      ;;
    -t | --tap )
      BATS_PRETTY_FORMAT=false
      ;;
    -p | --pretty )
      BATS_PRETTY_FORMAT=true
      ;;
    -* )
      echo "bad argument: $option" >&2
      usage >&2
      exit 1
      ;;
    *)
      arguments+=( "$1" )
  esac
  shift
done

if [ "${#arguments[@]}" -eq 0 ]; then
  echo 'no tests specified' >&2
  usage >&2
  exit 1
fi

filenames=()
for filename in "${arguments[@]}"; do
  expand_path "$filename" 'filename'

  if [ -d "$filename" ]; then
    shopt -s nullglob
    for suite_filename in "$filename"/*.bats; do
      filenames["${#filenames[@]}"]="$suite_filename"
    done
    shopt -u nullglob
  else
    filenames["${#filenames[@]}"]="$filename"
  fi
done
unset arguments

if [ "${#filenames[@]}" -eq 1 ]; then
  command="bats-exec-test"
else
  command="bats-exec-suite"
fi

set -o pipefail execfail
if [[ "$BATS_PRETTY_FORMAT" == false ]]; then
  exec "$command" "${filenames[@]}"
else
  formatter="bats-format-tap-stream"
  exec "$command" "${filenames[@]}" | "$formatter"
fi
