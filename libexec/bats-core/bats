#!/usr/bin/env bash
set -e

export BATS_VERSION='1.7.0'
VALID_FORMATTERS="pretty, junit, tap, tap13"

version() {
  printf 'Bats %s\n' "$BATS_VERSION"
}

abort() {
  local print_usage=1
  if [[ ${1:-} == --no-print-usage ]]; then
    print_usage=
    shift
  fi
  printf 'Error: %s\n' "$1" >&2
  if [[ -n $print_usage ]]; then
    usage >&2
  fi
  exit 1
}

usage() {
  local cmd="${0##*/}"
  local line

  cat <<HELP_TEXT_HEADER
Usage: ${cmd} [OPTIONS] <tests>
       ${cmd} [-h | -v]

HELP_TEXT_HEADER

  cat <<'HELP_TEXT_BODY'
  <tests> is the path to a Bats test file, or the path to a directory
  containing Bats test files (ending with ".bats")

  -c, --count               Count test cases without running any tests
  --code-quote-style <style>
                            A two character string of code quote delimiters
                            or 'custom' which requires setting $BATS_BEGIN_CODE_QUOTE and 
                            $BATS_END_CODE_QUOTE. Can also be set via $BATS_CODE_QUOTE_STYLE
  -e, --exclude <files>     Exclude file(s) from processing. File can also be a
                            directory itself. <files> are separated by space 
                            and enclosed in quotes, e.g. 
                            `--exclude 'foo.bats bar baz qux.bats'`
  -f, --filter <regex>      Only run tests that match the regular expression
  --filter-status <status>  Only run tests with the given status in the last completed (no CTRL+C/SIGINT) run.
                            Valid <status> values are:
                              failed - runs tests that failed or were not present in the last run
                              missed - runs tests that were not present in the last run
  -F, --formatter <type>    Switch between formatters: pretty (default),
                              tap (default w/o term), tap13, junit, /<absolute path to formatter>
  --gather-test-outputs-in <directory>
                            Gather the output of failing *and* passing tests
                            as files in directory (if existing, must be empty)
  -h, --help                Display this help message
  -j, --jobs <jobs>         Number of parallel jobs (requires GNU parallel)
  --no-tempdir-cleanup      Preserve test output temporary directory
  --no-parallelize-across-files
                            Serialize test file execution instead of running
                            them in parallel (requires --jobs >1)
  --no-parallelize-within-files
                            Serialize test execution within files instead of
                            running them in parallel (requires --jobs >1)
  --report-formatter <type> Switch between reporters (same options as --formatter)
  -o, --output <dir>        Directory to write report files (must exist)
  -p, --pretty              Shorthand for "--formatter pretty"
  --print-output-on-failure Automatically print the value of `$output` on failed tests
  -r, --recursive           Include tests in subdirectories
  --show-output-of-passing-tests
                            Print output of passing tests
  -t, --tap                 Shorthand for "--formatter tap"
  -T, --timing              Add timing information to tests
  -x, --trace               Print test commands as they are executed (like `set -x`)
  --verbose-run             Make `run` print `$output` by default
  -v, --version             Display the version number

  For more information, see https://github.com/bats-core/bats-core
HELP_TEXT_BODY
}

expand_path() {
  local path="${1%/}"
  local dirname="${path%/*}"
  local result="$2"

  if [[ "$dirname" == "$path" ]]; then
    dirname="$PWD"
  else
    cd "$dirname"
    dirname="$PWD"
    cd "$OLDPWD"
  fi
  printf -v "$result" '%s/%s' "$dirname" "${path##*/}"
}

# argument: exclude_literal
is_bats_file() {
  [[ "$1" == *".bats"* ]]
}

# argument suite_filename
is_excluded() {
  if [[ -z "$exclude_files" ]]; then
    return 1
  fi
  
  local suite_filename="$1"
  read -ra EXCLUDE_FILES <<< "$exclude_files"

  for exclude_file in "${EXCLUDE_FILES[@]}"
  do
    # 'file check' needed: $exclude_file can contain dir or file filter
    if is_bats_file "$exclude_file"; then
      if [[ "$suite_filename" == *"$exclude_file"* ]]; then
        return 0
      fi
    fi
  done

  return 1
}

# argument: exclude_literal
_build_exclude_pattern() {
  local result="$2"
  if is_bats_file "$1" ; then
    printf -v "$result" '%s' "'*$1'" # file matching pattern
  else
    printf -v "$result" '%s' "'*/$1/*'" # directory matching pattern
  fi
}

# argument: EXCLUDE_FILES
_build_multi_exclude_pattern() {
  local result="$2"
  # given performance concerns we concatenate and loop in a native c-style manner
  local exclude_pattern
  _build_exclude_pattern "${EXCLUDE_FILES[0]}" "excl_pattern"
  # shellcheck disable=SC2154
  exclude_pattern="-path $excl_pattern"
  local files_length=${#EXCLUDE_FILES[@]}
  for ((i=1;i<files_length;i++))
  do
    _build_exclude_pattern "${EXCLUDE_FILES[i]}" "excl_pattern"
    exclude_pattern="${exclude_pattern} -o -path $excl_pattern"
  done
  printf -v "$result" %s "$exclude_pattern"
}

# builds and returns specific `find` command as string literal 
# according given user input to the bat command.
# 
# internals: performance over fancy code
# - using printf -v instead of command substitution for return values
# - using find combined with -prune instead of piping with grep/awk etc.
# - use of sub processes limited to the absolute minimum.
#
build_find_command_string() {
  local result="$1"
  if [[ -z "$exclude_files" ]]; then
    printf -v "$result" %s \
      "find -L $filename -type f \
        -name '*.${BATS_FILE_EXTENSION:-bats}'"
    return 0
  fi

  # parsing procedure in terms of performance:
  # choose array combined with looping (`read -ra`) 
  # over one liners with grep, sed/awk etc.
  read -ra EXCLUDE_FILES <<< "$exclude_files"

  # shellcheck disable=SC2154
  if [[ ${#EXCLUDE_FILES[@]} -eq 1 ]]; then
    _build_exclude_pattern """${EXCLUDE_FILES[0]}""" 'excl_pattern'
    printf -v "$result" %s \
      "find -L $filename -type f,d \
        \( -path $excl_pattern \) \
        -prune -o -name '*.${BATS_FILE_EXTENSION:-bats}'"
  else
    _build_multi_exclude_pattern "${EXCLUDE_FILES[@]}" 'multi_excl_pattern'
    printf -v "$result" %s \
      "find -L $filename -type f,d \
        \( $multi_excl_pattern \) \
        -prune -o -name '*.${BATS_FILE_EXTENSION:-bats}'"
  fi
}

BATS_LIBEXEC="$(cd "$(dirname "$(bats_readlinkf "${BASH_SOURCE[0]}")")"; pwd)"
export BATS_LIBEXEC
export BATS_CWD="$PWD"
export BATS_TEST_FILTER=
export PATH="$BATS_LIBEXEC:$PATH"
export BATS_ROOT_PID=$$
export BATS_TMPDIR="${TMPDIR:-/tmp}"
BATS_TMPDIR=${BATS_TMPDIR%/} # chop off trailing / to avoid duplication
export BATS_RUN_TMPDIR=
export BATS_GUARANTEED_MINIMUM_VERSION=0.0.0

if [[ ! -d "${BATS_TMPDIR}" ]];then
  printf "Error: BATS_TMPDIR (%s) does not exist or is not a directory" "${BATS_TMPDIR}" >&2
  exit 1
elif [[ ! -w "${BATS_TMPDIR}" ]];then
  printf "Error: BATS_TMPDIR (%s) is not writable" "${BATS_TMPDIR}" >&2
  exit 1
fi

unset flags recursive formatter_flags
arguments=()
flags=('--dummy-flag') # add a dummy flag to prevent unset variable errors on empty array expansion in old bash versions
formatter_flags=('--dummy-flag') # add a dummy flag to prevent unset variable errors on empty array expansion in old bash versions
formatter='tap'
report_formatter=''
recursive=
exclude_files=
setup_suite_file=''
export BATS_TEMPDIR_CLEANUP=1
output=
if [[ -z "${CI:-}" && -t 0 && -t 1 ]] && command -v tput >/dev/null; then
  formatter='pretty'
fi

while [[ "$#" -ne 0 ]]; do
  case "$1" in
  -h | --help)
    version
    usage
    exit 0
    ;;
  -v | --version)
    version
    exit 0
    ;;
  -c | --count)
    flags+=('-c')
    ;;
  -e | --exclude)
    shift
    exclude_files="$1"
    ;;
  -f | --filter)
    shift
    flags+=('-f' "$1")
    ;;
  -F | --formatter)
    shift
    # allow cat formatter to see extended output but don't advertise to users
    if [[ $1 =~ ^(pretty|junit|tap|tap13|cat|/.*)$ ]]; then
      formatter="$1"
    else
      printf "Unknown formatter '%s', valid options are %s\n" "$1" "${VALID_FORMATTERS}"
      exit 1
    fi
    ;;
  --report-formatter)
    shift
    if [[ $1 =~ ^(pretty|junit|tap|tap13)$ ]]; then
      report_formatter="$1"
    else
      printf "Unknown report formatter '%s', valid options are %s\n" "$1" "${VALID_FORMATTERS}"
      exit 1
    fi
    ;;
  -o | --output)
    shift
    output="$1"
    ;;
  -p | --pretty)
    formatter='pretty'
    ;;
  -j | --jobs)
    shift
    flags+=('-j' "$1")
    ;;
  -r | --recursive)
    recursive=0
    ;;
  -t | --tap)
    formatter='tap'
    ;;
  -T | --timing)
    flags+=('-T')
    formatter_flags+=('-T')
    ;;
  # this flag is now a no-op, as it is the parallel default
  --parallel-preserve-environment)
    ;;
  --no-parallelize-across-files)
    flags+=("--no-parallelize-across-files")
    ;;
  --no-parallelize-within-files)
    flags+=("--no-parallelize-within-files")
    ;;
  --no-tempdir-cleanup)
    BATS_TEMPDIR_CLEANUP=''
    ;;
  --tempdir) # for internal test consumption only!
    BATS_RUN_TMPDIR="$2"
    shift
    ;;
  -x | --trace)
    flags+=(--trace)
    ;;
  --print-output-on-failure)
    flags+=(--print-output-on-failure)
    ;;
  --show-output-of-passing-tests)
    flags+=(--show-output-of-passing-tests)
    ;;
  --verbose-run)
    flags+=(--verbose-run)
    ;;
  --gather-test-outputs-in)
    shift
    output_dir="$1"
    if [ -d "$output_dir" ]; then
      if ! find "$output_dir" -mindepth 1 -exec false {} + 2>/dev/null; then
        abort --no-print-usage "Directory '$output_dir' must be empty for --gather-test-outputs-in"
      fi
    elif ! mkdir "$output_dir" 2>/dev/null; then
      abort --no-print-usage "Could not create '$output_dir' for --gather-test-outputs-in"
    fi
    flags+=(--gather-test-outputs-in "$output_dir")
    ;;
  --setup-suite-file)
    shift
    setup_suite_file="$1"
    ;;
  --code-quote-style)
    shift
    BATS_CODE_QUOTE_STYLE="$1"
  ;;
  --filter-status)
    shift
    flags+=('--filter-status' "$1")
    ;;
  -*)
    abort "Bad command line option '$1'"
    ;;
  *)
    arguments+=("$1")
    ;;
  esac
  shift
done

if [[ -n "${BATS_RUN_TMPDIR:-}" ]];then
  if [[ -d "$BATS_RUN_TMPDIR" ]]; then
    printf "Error: BATS_RUN_TMPDIR (%s) already exists\n" "$BATS_RUN_TMPDIR" >&2
    printf "Reusing old run directories can lead to unexpected results ... aborting!\n" >&2
    exit 1
  elif ! mkdir -p "$BATS_RUN_TMPDIR" ;then
    printf "Error: Failed to create BATS_RUN_TMPDIR (%s)\n" "$BATS_RUN_TMPDIR" >&2
    exit 1
  fi
elif ! BATS_RUN_TMPDIR=$(mktemp -d "${BATS_TMPDIR}/bats-run-XXXXXX");then
  printf "Error: Failed to create BATS_RUN_TMPDIR (%s) with mktemp\n" "${BATS_TMPDIR}/bats-run-XXXXXX" >&2
  exit 1
fi

export BATS_WARNING_FILE="${BATS_RUN_TMPDIR}/warnings.log"

bats_exit_trap() {
  if [[ -s "$BATS_WARNING_FILE" ]]; then
    if [[ $formatter == pretty ]]; then
      PRE_CAT=$'\x1B[31m'
      POST_CAT=$'\x1B[0m'
    fi
    printf "\nThe following warnings were encountered during tests:\n%s" "$PRE_CAT"
    cat "$BATS_WARNING_FILE"
    printf "%s" "$POST_CAT"
  fi >&2

  if [[ -n "$BATS_TEMPDIR_CLEANUP" ]]; then
    rm -rf "$BATS_RUN_TMPDIR"
  else
    printf "BATS_RUN_TMPDIR: %s\n" "$BATS_RUN_TMPDIR" >&2
  fi
}

trap bats_exit_trap EXIT

if [[ "$formatter" != "tap" ]]; then
  flags+=('-x')
fi

if [[ -n "$report_formatter" && "$report_formatter" != "tap" ]]; then
  flags+=('-x')
fi

if [[ "$formatter" == "junit" ]]; then
  flags+=('-T')
  formatter_flags+=('--base-path' "${arguments[0]}")
fi
if [[ "$report_formatter" == "junit" ]]; then
  flags+=('-T')
  report_formatter_flags+=('--base-path' "${arguments[0]}")
fi

if [[ "$formatter" == "pretty" ]]; then
  formatter_flags+=('--base-path' "${arguments[0]}")
fi

# if we don't need to filter extended syntax, use the faster formatter
if [[ "$formatter" == tap && -z "$report_formatter" ]]; then
  formatter="cat"
fi

bats_check_formatter() { # <formatter-path>
  local -r formatter="$1"
  if [[ ! -f "$formatter" ]]; then
    printf "ERROR: Formatter '%s' is not readable!\n" "$formatter"
    exit 1
  elif [[ ! -x "$formatter" ]]; then
    printf "ERROR: Formatter '%s' is not executable!\n" "$formatter"
    exit 1
  fi
}

if [[ $formatter == /* ]]; then # absolute paths are direct references to formatters
  bats_check_formatter "$formatter"
  interpolated_formatter="$formatter"
else
  interpolated_formatter="bats-format-${formatter}"
fi

if [[ "${#arguments[@]}" -eq 0 ]]; then
  abort 'Must specify at least one <test>'
fi

if [[ -n "$report_formatter" ]]; then
  # default to the current directory for output
  if [[ -z "$output" ]]; then
    output=.
  fi
  # only set BATS_REPORT_FILENAME if none was given
  if [[ -z "${BATS_REPORT_FILENAME:-}" ]]; then
    case "$report_formatter" in
      tap|tap13)
        BATS_REPORT_FILE_NAME="report.tap"
        ;;
      junit)
        BATS_REPORT_FILE_NAME="report.xml"
        ;;
      *)
        BATS_REPORT_FILE_NAME="report.log"
        ;;
    esac
  fi
fi

if [[ $report_formatter == /* ]]; then # absolute paths are direct references to formatters
  bats_check_formatter "$report_formatter"
  interpolated_report_formatter="${report_formatter}"
else
  interpolated_report_formatter="bats-format-${report_formatter}"
fi

if [[ "${BATS_CODE_QUOTE_STYLE-BATS_CODE_QUOTE_STYLE_UNSET}" == BATS_CODE_QUOTE_STYLE_UNSET ]]; then
  BATS_CODE_QUOTE_STYLE="\`'"
fi

case "${BATS_CODE_QUOTE_STYLE}" in
  ??)
    BATS_BEGIN_CODE_QUOTE="${BATS_CODE_QUOTE_STYLE::1}"
    BATS_END_CODE_QUOTE="${BATS_CODE_QUOTE_STYLE:1:1}"
    export BATS_BEGIN_CODE_QUOTE BATS_END_CODE_QUOTE
  ;;
  custom)
    if [[ ${BATS_BEGIN_CODE_QUOTE-BATS_BEGIN_CODE_QUOTE_UNSET} == BATS_BEGIN_CODE_QUOTE_UNSET 
        || ${BATS_END_CODE_QUOTE-BATS_BEGIN_CODE_QUOTE_UNSET} == BATS_BEGIN_CODE_QUOTE_UNSET ]]; then
      printf "ERROR: BATS_CODE_QUOTE_STYLE=custom requires BATS_BEGIN_CODE_QUOTE and BATS_END_CODE_QUOTE to be set\n" >&2
      exit 1
    fi
  ;;
  *)
    printf "ERROR: Unknown BATS_CODE_QUOTE_STYLE: %s\n" "$BATS_CODE_QUOTE_STYLE" >&2
    exit 1
  ;;
esac

if [[ -n "$output" ]]; then
  if [[ ! -w "${output}" ]]; then
    abort "Output path ${output} is not writeable"
  fi
  export BATS_REPORT_OUTPUT_PATH="$output"
fi

if [[ -n "$setup_suite_file" && ! -f "$setup_suite_file" ]]; then
  abort "--setup-suite-file $setup_suite_file does not exist!"
fi

filenames=()
for filename in "${arguments[@]}"; do
  expand_path "$filename" 'filename'

  if [[ -z "$setup_suite_file" ]]; then
    if [[ -d "$filename" ]]; then
      dirname="$filename"
    else
      dirname="${filename%/*}"
    fi
    potential_setup_suite_file="$dirname/setup_suite.bash"
    if [[ -e "$potential_setup_suite_file" ]]; then
      setup_suite_file="$potential_setup_suite_file"
    fi
  fi

  if [[ -d "$filename" ]]; then
    shopt -s nullglob
    if [[ "$recursive" == "0" ]]; then
      build_find_command_string "find_command"

      # shellcheck disable=SC2154 
      while IFS= read -r -d $'\0' file; do
        filenames+=("$file")   
        # performance boost through piping by /dev/fd/63 instead of
        # creating a temporary file for find's results.
        # => pipe [<(..)] and redirect [<] '$find_command' to standard input.
        # for `read` using c-style string termination '\0' [-print0]
        # eval is a built-in command, no performance issue's expected
      done < <(eval "$find_command" -print0 | sort -z)
    else
      for suite_filename in "$filename"/*."${BATS_FILE_EXTENSION:-bats}"; do
        if ! is_excluded "$suite_filename" ; then
          filenames+=("$suite_filename")
        fi
      done
    fi
    shopt -u nullglob
  else
    filenames+=("$filename")
  fi
done

if [[ -n "$setup_suite_file" ]]; then
  flags+=("--setup-suite-file" "$setup_suite_file")
fi

# shellcheck source=lib/bats-core/validator.bash
source "$BATS_ROOT/lib/bats-core/validator.bash"

trap 'BATS_INTERRUPTED=true' INT # let the lower levels handle the interruption

set -o pipefail execfail

if [[ -n "$report_formatter" ]]; then
  exec bats-exec-suite "${flags[@]}" "${filenames[@]}" | \
    tee >("$interpolated_report_formatter" "${report_formatter_flags[@]}" >"${BATS_REPORT_OUTPUT_PATH}/${BATS_REPORT_FILE_NAME}") | \
    bats_test_count_validator | \
    "$interpolated_formatter" "${formatter_flags[@]}"
else
  exec bats-exec-suite "${flags[@]}" "${filenames[@]}" | \
    bats_test_count_validator | \
    "$interpolated_formatter" "${formatter_flags[@]}"
fi
